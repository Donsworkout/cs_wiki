### Chapter 10 Exercise

10.1  
어떠한 상황들에서 페이지 폴트가 나는가? 페이지 폴트가 났을때 OS가 취하는 액션을 설명해 보아라.

A)  
페이지 테이블의 유효비트가 0이라면 (물리 메모리에 찾는 엔트리가 없다면) 페이지 폴트가 일어난다.  
OS는 메모리 접근을 확인하고 유효하지 않은 접근이라면 프로그램 실행을 취소한다. 만약에 유효한 접근이라면 물리 메모리의 free frame 에 Disk 에서 읽은 페이지를 읽어들인다.  
I/O 완료까지, 프로세스 테이블과 페이지 테이블은 갱신되고 명령어는 재시작된다. 

10.2  
m개의 프레임이 있는 프로세스에 대해 페이지 참조 문자열이 있다고 가정하라 (처음에는 모두 비어있는 상태) 페이지 참조 문자열의 길이는 p 이고, n개의 서로 다른 페이지 번호들이 있다.  
어떠한 페이지 교체 정책들에게도 적용되도록 아래의 질문들에 답하라.

a) 페이지 폴트가 나는 최소 페이지 수? n  
b) 페이지 폴트가 나는 최대 페이지 수? p

10.3  
다음 페이지 교체 알고리즘을 고려하라.  
페이지 폴트 확률에 따라 bad 에서 perfect 까지의 5점 척도로 이러한 알고리즘의 순위를 매기고,  
벨라디의 이상 징후(Belady’s anomaly) 로 고통 받는 알고리즘과 그렇지 않은 알고리즘을 분리한다.

a) LRU 교체

b) FIFO 교체

c) Optimal replacement

d) Second-chance replacement

![스크린샷 2019-12-09 오후 9 04 17](https://user-images.githubusercontent.com/26560119/70434434-83c8a400-1ac7-11ea-9efa-86b4b5509297.png)

Belady's Anomaly 란?

> 간단히 말해서 페이지 교체 알고리즘 중의 하나인 FIFO(First In First Out)에서, 원래 페이지 프레임의 개수를 늘리면 page fault발생이 감소 해야 하나, 오히려 늘어나는 경우가 발생하는데 그것을 Belady's Anomaly라 한다.

** 10.4  
운영 체제는 1마이크로초의 사이클 시간을 가진 중앙 프로세서를 사용하여 호출된 가상 메모리를 지원한다. 현재 페이지 이외의 페이지에 접속하려면 1마이크로초가 더 든다. 페이지는 1000개의 word를 가지고 있으며, 페이징 장치는 분당 3000회 회전하여 초당 100만 워드를 전송하는 드럼이다.  
또한, 실행된 모든 명령의 1%가 현재 페이지가 아닌 다른 페이지에 액세스했다

다른 페이지에 액세스한 명령어는 이미 메모리에 있는 페이지에 80%가 액세스했으며 새 페이지가 필요할 때 교체된 페이지가 50% 수정되었다. 시스템이 하나의 프로세스만 실행되고 드럼 전송 중에 프로세서가 유휴 상태라고 가정할 때 이 시스템에서 유효한 액세스 시간은?

EAT = (1 – p) x memory access + p (page fault overhead + swap page out + swap page in )

~~~
effective access time = 
0.99 × (1 sec + 0.008 × (2 sec)
+ 0.002 × (10,000 sec + 1,000 sec)
+ 0.001 × (10,000 sec + 1,000 sec)
= (0.99 + 0.016 + 22.0 + 11.0) sec
= 34.0 sec
~~~

** 10.5  
12비트의 가상 및 물리 주소 체계를 가진 페이지 테이블이 있고, 256 바이트의 페이지를 가지고 있다고 가정해보자 

![스크린샷 2019-12-09 오후 9 46 27](https://user-images.githubusercontent.com/26560119/70436751-60a0f300-1acd-11ea-8a41-395056cc48a9.png)

free page frame 리스트를 순서대로 D, E, F 라고 하자. 페이지 프레임의 '-' 표시는 페이지가  메모리에 없다는 뜻이다. 아래의 가상 주소를 16진수 물리 메모리 주소로 변환하라 


9EF -> 0

111 ->

700 -> 

0FF -> 

10.6  
요구 페이징을 지원하기 위해 필요한 하드웨어 지원은? 

A)  
모든 메모리 액세스 작업시, 페이지 테이블은 해당되는 페이지가 메모리에 있는지 확인해야 하고 또한,  페이지에 액세스를 하기 위해 읽기 쓰기 권한이 있는지 여부를 체크한다. 이러한 점검은 하드웨어가 제공하고 TLB(Translate Lookaside Buffer) 는 페이지 테이블의 캐시 역할을 제공한다. (가상 - 물리주소 사상)

10.7  
이차원 배열이 있다고 가정해 보자  

~~~c
int A[][] = new int[100][100];
~~~

여기서 A[0][0] 는 페이지 크기가 200인 호출된 메모리 시스템의 위치 200에 있다.  
매트릭스를 조작하는 작은 프로세스가 0페이지(위치 0 ~ 199)에 있다.  
따라서 모든 명령어는 0페이지에서 가져올 것이다.  
3페이지 프레임의 경우 다음 어레이 초기화 루프에 의해 생성되는 페이지 폴트 수는?

LRU 교체를 사용하고, 페이지 프레임 1에 프로세스가 포함되어 있고 다른 두 개가 처음에 비어 있다고 가정한다

a. 
~~~c
for (int j = 0; j < 100; j++)
  for (int i = 0; i < 100; i++)
    A[i][j] = 0
~~~

100 x 100 / 2

b. 
~~~c
for (int i = 0; i < 100; i++)
  for (int j = 0; j < 100; j++)
    A[i][j] = 0
~~~

100 / 2