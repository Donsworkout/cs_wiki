### Memory Management

- CPU가 직접 접근하는 자원 : Memory / Register

- 메모리는 레지스터에 비해 느리다 (load / store 시, 캐시_sram 사용)

- 메모리 할당 / 효율적 사용에 관한 이야기들 
  - MMU를 CPU에 구현
  - OS의 관여를 최소로 (HW/Compiler dependent)
  - CPU 내 HW 기능 지원이 절대적으로 필요

- 메모리 모자르면 Swap 

- Paging / Segmentation

### Base and Limit Registers

<img width="481" alt="스크린샷 2019-12-08 오전 11 47 08" src="https://user-images.githubusercontent.com/26560119/70383389-92706780-19b0-11ea-856b-0537ff8c5615.png">

### Address Binding

> 주소 바인딩 방식

- 소스코드 - 심벌릭
- 컴파일된 코드 - 할당가능 주소
- 링커, 로더가 할당가능 주소를 절대 주소로 변경
- 각각의 바인딩은 1:1 관계

### 명령어 / 데이터 메모리 바인딩 시점

- Complile time binding
  - 컴파일러가 프로세스가 어디에 적재될지 알고 있으면 컴파일할 때 주소를 바인딩할 수 있다.
- Load time binding
  - 컴파일할 때 프로세스가 어디에 적재될지 모르면 컴파일러는 재배치 가능 코드를 생성한다. 실제 바인딩은 적재할 때까지 지연된다. 재배치 가능 코드란 기준 위치 주소를 사용하는 코드를 말한다.
- Execution time binding
  - 실행 도중에 프로세스의 적재 위치가 바뀔 수 있으면 바인딩은 실행될 때 이루어진다.

### 논리주소 vs 물리주소 

- 논리 주소 : CPU에 의해 생성되는 가상 주소

- 물리 주소 : 메모리 유닛이 보는 실제 주소 

- 컴파일, 로드타임 때 주소 확정시 논리 / 물리 주소 같지만 실행시간 바인딩일 경우 다르다  
이때 논리주소를 가상 주소라고 부흔다.

### MMU

- MMU 란 런타임에 논리(가상) 주소를 물리적 주소로 매핑해 주는 장치

- Base Register 은 재할당 레지스터라고 불린다 (재할당 가능)

### Dynamic Relocation (동적 적재)

![스크린샷 2019-12-08 오후 12 25 28](https://user-images.githubusercontent.com/26560119/70383714-d619a000-19b5-11ea-929f-a17d3660f7ee.png)

- 불리기 전까지 루틴 로딩 안됨, 필요할때 루틴 주기억장치에 적재

- 모든 루탄은 재배치 가능 코드 형태로 디스크에 저장

- OS 도움이 필요없다 (라이브러리 도움은 줄 수 있음)

### Dynamic Linking

#### Static Linking

> 프로그래밍 언어 라이브러리를 프로그램과 결합하여 사용

- 라이브러리 복사본을 프로그램이 가지고 있어야 해서 공간 낭비

#### Dynamic Linking

> 라이브러리와의 연결이 실행 시간까지 연기

- 각 프로그램에 stub 이 포함 (stub은 프로그램이 필요한 라이브러리 찾는 코드)

- 루틴 처름 부를 때만 stub 필요, 다음부터는 바로 주소를 통해 호출 

- 라이브러리 갱신 용이하고 공간 절약됨

#### Swaping

> 프로세스 실행 도중 일시적으로 메모리에서 디스크로 옮겨지고 적절할 때 다시 적재, 이것이 스왑핑

<img src="https://t1.daumcdn.net/cfile/tistory/25673A4C5643440215"/>

### Contiguos Memory Allocation (연속적 공간 할당)

- 메모리는 운영체제 영역과 사용자 프로세스 영역으로 분리됨 (OS는 하위 주소에 위치)

- 각 사용자 프로세스는 연속된 단일 영역을 할당받는다.

- OS는 사용자 프로세스로 부터, 사용자 프로세스는 다른 사용자 프로세스로 부터 보호받는다.

- Base + Limit Register 을 사용한다.

- 처음에는 OS 영역 제외하고 다른 공간을 모두 사용 가능하고, 이를 Hole 이라고 한다.

### 어떤 hole 에 프로세스를 할당할 것인가?

- First Fit 

> 충분히 큰 홀 중 첫번째 홀에 할당 

- Best Fit 

> 프로세스를 수용할 수 있는 가장 작은 홀에 할당 (효율)

- Worst Fit

> 프로세스를 수용할 수 있는 가장 큰 홀에 할당 (비효율)

#### 발생할 수 있는 Fragmentation (단편화)

1. 내부 단편화

> 메모리 공간은 50mb 인데 프로세스는 30mb 라서 20mb 낭비되는 것

2. 외부 단편화 

> 세그먼트 간 구멍이 숭숭 뚫린 것 

### Segmentation

![스크린샷 2019-12-08 오후 1 11 56](https://user-images.githubusercontent.com/26560119/70384074-54794080-19bc-11ea-9a24-2e78a0dc8fd0.png)

> 세그먼테이션은 각 세그먼트의 사이즈가 다 다르고 매핑 테이블이 있다. (Base + Limit - 크기)  
그리고 프로세스에게 연속된 공간을 할당해 주어야 한다. 

### Paging

![스크린샷 2019-12-08 오후 1 27 11](https://user-images.githubusercontent.com/26560119/70384207-783d8600-19be-11ea-9d5d-738c941acd06.png)

> 가장 널리 쓰이는 방식으로 프로세스에게 연속된 공간 할당하지 않아도 됨

- 물리적 기억장치는 고정된 크기의 FRAME 으로 나눔
- 논리적 주소공간은 고정된 크기의 PAGE 로 나눔
- 페이지 크기는 4KB / 8KB
- 페이지 번호(p) 와 오프셋(d) 으로 구성 
- 페이지 테이블에서 논리 메모리와 물리 메모리 매핑 
- 외부 단편화는 방지할 수 있지만, 내부 단편화 생김 (따라서 페이지 크기를 줄임)
- 페이지 크기 너무 줄이면 페이지 테이블 크기도 커지고, context switching 시간 증가 

페이지 프레임 사상 정보를 위해 페이지 테이블 존재 

![스크린샷 2019-12-08 오후 1 39 39](https://user-images.githubusercontent.com/26560119/70384306-37df0780-19c0-11ea-90e4-6b3f4b4dcc5a.png)

### 페이지 테이블 하드웨어 구현

- 보호비트나 PTBR(page table base register), PTLR(page table length register) 을 이용하여 페이지 테이블의 크기를 나타내에 고유의 영역을 보호한다.

- 전용 레지스터 집합 사용 
  - 메모리의 특정 영역에 페이지 테이블을 저장하고, 그것을 가리키는 주소만 PRBR에 저장
  - 메모리에 접근하기위해 IO 두번이 발생하므로 느리다 (데이터 / 명령어 접근 각 1번)

- 전용 캐시 사용 (TLB - Translation Look Aside Buffer)
  - 페이지 테이블 일부만 가지고 있고, 메모리 검색 전에 TLB 부터 검색
  - Replacement Policy 사용

### 페이지 테이블의 구조 

> 32 비트 주소 체계에서 페이지 사이즈가 4KB 일때, 페이지 테이블에는 2^32 / 2^12 = 2^20 엔트리가 존재

### 페이지 테이블 종류 

1. Two Level Page Table 

![스크린샷 2019-12-08 오후 2 21 48](https://user-images.githubusercontent.com/26560119/70384687-18e37400-19c6-11ea-83f2-3b7da5b7790c.png)

2. Inverted Page Table

![스크린샷 2019-12-08 오후 2 23 30](https://user-images.githubusercontent.com/26560119/70384706-6f50b280-19c6-11ea-9622-f65ea494feb9.png)

- 기존 페이지 테이블의 경우 각 프로세스마다 본인의 페이지 테이블 가짐

- 따라서 많은 프로세스 실행시 페이지 테이블 차지 메모리 양 늘어남 

- 이것에 대한 해결책이 역 페이지 테이블 

- 역 페이지 테이블은 전체 시스템에서 단 하나의 global page table 가짐

- 따라서 페이지 테이블 엔트리에 pid 를 가지고 있음 

- 역 페이지 테이블은 실제 메모리 프레임 주소를 가상 주소로 매핑시킴으로서 메모리 크기도 줄인다. 

- 역 페이지 테이블에서 엔트리 갯수 : 물리적 주소 공간 / 페이지 크기

- 대신 주소변환 요청시 전체 테이블 탐색해야 하는것이 단점

- **cpu에서 논리 주소를 내보내면 pid와 page number비트를 가지고 페이지 테이블을 탐색한다.  
일치하는 엔트리를 발견시 그 엔트리의 주소 값(i)와 변위 비트(d)를 합쳐서 물리적 주소를 생성하고 메모리에 접근한다.**

### 가상 메모리

> 프로그램 실행하는 동안 종종 프로그램 전체를 모두 사용하지 않는다.  
프로그램의 일부만 메모리에 있어도 실행이 가능하도록!

- 요구 페이징과 세그멘테이션 기법과 결합하여 사용

#### Demand Paging

- 스와팡 + 페이징을 결합하여 사용 

- 프로세스 전체를 스왑하지 않고, lazy swapper 사용

- lazy swapper 은 페이지가 필요할때만 적재한다. 

- 유효비트가 1이면 페이지 테이블에 엔트리 존재 

#### 페이지 폴트 과정

![스크린샷 2019-12-08 오후 3 41 49](https://user-images.githubusercontent.com/26560119/70385485-4681ea80-19d1-11ea-9e1c-8b6707ed1a8d.png)

1. 접근하는 페이지에 대해 페이지 테이블을 참조하면 유효비트가 현재 0이므로 page fault trap 발생

2. 트랩이 발생하면 프로세스의 PCB를 검사하여 참조의 유효성을 검사. 즉, 디스크에 있는 페이지에 대한 참조인지 프로세스의 가상 주소 공간을 벗어난 참조인지를 검사한다. 후자이면 프로세스 종료.

3. 빈 프레임을 찾는다.

4. 디스크 입출력을 이용하여 페이지를 프레임에 적재한다.

5. 디스크 입출력이 종료되면 프로세스의 내부 테이블과 페이지 테이블을 수정한다.

6. 페이지 결합 트랩을 발생시킨 명령어를 다시 수행한다.

#### EAT (Effective Access Time)

EAT =  
(1 – p) x memory access + p (page fault overhead + swap page out + swap page in )

#### Copy on Write

> 부모 프로세스가 자식 프로세스 생성시 부모 프로세스의 주소 공간 복사는 낭비이고, 변경된 페이지 내용만 복사하고 나머지는 공유하는 것 

![스크린샷 2019-12-08 오후 3 51 46](https://user-images.githubusercontent.com/26560119/70385554-a9c04c80-19d2-11ea-8831-5bc7a3aa43f3.png)

#### Page Replacement

> 페이지 테이블에 적재되어 있는 기존 페이지를 새 페이지로 교체하는 방식  
페이지 폴트가 발생할 때  교체한다. 

![스크린샷 2019-12-08 오후 3 55 37](https://user-images.githubusercontent.com/26560119/70385782-c9a44000-19d3-11ea-9d02-76a0463efad6.png)

1. 디스크에서 페이지의 위치를 찾는다

2. 빈 프레임을 찾는다. 

    - 빈 프레임이 있다면, 거기에 페이지를 적재한다.

    - 빈 프레임이 없다면, 페이지 교체 알고리즘으로 희생 프레임을 선택하여  
    희생 프레임에 있는 페이지를 디스크에 쓰고, 프레임에서 새 페이지를 적재 

3. 페이지 테이블과 프레임 테이블을 갱신 

4. 프로세스 재개 

#### FIFO / LRU 등 페이지 교채 방식이 존재 

#### Thrashing

> 프로세스가 충분한 프레임이 없을 때, 페이지 폴트 확률이 매우 높다  
실행 시간보다 페이지 폴트 처리 시간이 더 많아지먄 이런 현상이 발생한다.  
즉 지역성을 고려하면 (현재 프로세스 지역 수용 가능하도록 프레임 할당) 해결 가능  
암튼 프로세스가 페이지 스와핑 하면서 바쁜것을 스래싱이라고 함 

